#include "minidb.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <zlib.h>
#include "wal.h"
// åˆå§‹åŒ–æ•°æ®åº“
void init_db(MiniDB *db, const char *data_dir) {
    // è®¾ç½®æ•°æ®ç›®å½•
    strncpy(db->data_dir, data_dir, sizeof(db->data_dir));
    mkdir(data_dir, 0755);
    
    // åˆå§‹åŒ–ç³»ç»Ÿç›®å½•
    init_system_catalog(&db->catalog);
    
    // åˆå§‹åŒ–äº‹åŠ¡ç®¡ç†å™¨
    txmgr_init(&db->tx_mgr);
    
    // åˆå§‹æ— æ´»åŠ¨äº‹åŠ¡
    db->current_xid = INVALID_XID;
    
    // åˆå§‹åŒ–WAL
    init_wal();
    
    // ä»WALæ¢å¤
   // recover_from_wal(db);
}

// å¼€å§‹äº‹åŠ¡
uint32_t begin_transaction(MiniDB *db) {
    if (db->current_xid != INVALID_XID) {
        fprintf(stderr, "Error: Transaction already in progress\n");
        return INVALID_XID;
    }
    
    db->current_xid = txmgr_start_transaction(&db->tx_mgr);
    return db->current_xid;
}

// æäº¤äº‹åŠ¡
int commit_transaction(MiniDB *db) {
    if (db->current_xid == INVALID_XID) {
        fprintf(stderr, "Error: No active transaction\n");
        return -1;
    }
    
    txmgr_commit_transaction(&db->tx_mgr, db->current_xid);
    wal_log_commit(db->current_xid);
    db->current_xid = INVALID_XID;
    return 0;
}

// å›æ»šäº‹åŠ¡
int rollback_transaction(MiniDB *db) {
    if (db->current_xid == INVALID_XID) {
        fprintf(stderr, "Error: No active transaction\n");
        return -1;
    }
    
    txmgr_abort_transaction(&db->tx_mgr, db->current_xid);
    wal_log_abort(db->current_xid);
    db->current_xid = INVALID_XID;
    return 0;
}

// åˆ›å»ºè¡¨
int db_create_table(MiniDB *db, const char *table_name, ColumnDef *columns, uint8_t col_count) {
    if (db->current_xid == INVALID_XID) {
        fprintf(stderr, "Error: No active transaction\n");
        return -1;
    }
    
    // åœ¨ç³»ç»Ÿç›®å½•ä¸­åˆ›å»ºè¡¨
    int oid = create_table(&db->catalog, table_name, columns, col_count);
    if (oid < 0) {
        fprintf(stderr, "Error: Failed to create table '%s'\n", table_name);
        return -1;
    }
    
    // è·å–è¡¨å…ƒæ•°æ®
    TableMeta *meta = find_table(&db->catalog, table_name);
    if (!meta) {
        fprintf(stderr, "Error: Failed to find table '%s' after creation\n", table_name);
        return -1;
    }
    
    // åˆ›å»ºæ•°æ®æ–‡ä»¶
    char path[256];
    snprintf(path, sizeof(path), "%s/%s", db->data_dir, meta->filename);
    int fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("Error: Failed to create table file");
        return -1;
    }
    close(fd);
    
    // è®°å½•WAL
    wal_log_create_table(meta, db->current_xid);
    
    return oid;
}

// æ’å…¥æ•°æ®
int db_insert(MiniDB *db, const char *table_name, Tuple *tuple) {
    if (db->current_xid == INVALID_XID) {
        fprintf(stderr, "Error: No active transaction\n");
        return -1;
    }
    
    TableMeta *meta = find_table(&db->catalog, table_name);
    if (!meta) {
        fprintf(stderr, "Error: Table '%s' not found\n", table_name);
        return -1;
    }
    
    // è®¾ç½®å…ƒç»„çš„MVCCä¿¡æ¯
    tuple->xmin = db->current_xid;
    tuple->xmax = INVALID_XID;
    tuple->deleted = false;
    
    // åˆ†é…å…ƒç»„OIDï¼ˆå¦‚æœå°šæœªåˆ†é…ï¼‰
    if (tuple->oid == 0) {
        tuple->oid = db->catalog.next_oid++;
    }
    
    // è®°å½•WAL
    wal_log_insert(db->current_xid, meta->oid, tuple);
    
    // æ„é€ è¡¨æ•°æ®æ–‡ä»¶è·¯å¾„
    char path[256];
    snprintf(path, sizeof(path), "%s/%u.dat", db->data_dir, meta->oid);
    
    // æŸ¥æ‰¾æœ‰ç©ºé—´çš„é¡µé¢
    PageID current_page_id = meta->first_page;
    Page current_page;
    int inserted = 0;
    
    while (current_page_id != INVALID_PAGE_ID) {
        if (read_page(path, current_page_id, &current_page) != 0) {
            break;
        }
        
        // å°è¯•æ·»åŠ å…ƒç»„
        if (add_tuple_to_page(&current_page, tuple) >= 0) {
            // å†™å…¥é¡µé¢
            if (write_page(path, &current_page) == 0) {
                inserted = 1;
                break;
            }
        }
        
        // ç§»åŠ¨åˆ°ä¸‹ä¸€é¡µ
        current_page_id = current_page.header.next_page;
    }
    
    // æ‰€æœ‰é¡µé¢éƒ½æ»¡äº†ï¼Œåˆ†é…æ–°é¡µé¢
    if (!inserted) {
        PageID new_page_id = allocate_page(path);
        if (new_page_id == INVALID_PAGE_ID) {
            fprintf(stderr, "Error: Failed to allocate new page\n");
            return -1;
        }
        
        // è¯»å–æ–°é¡µé¢
        if (read_page(path, new_page_id, &current_page) != 0) {
            fprintf(stderr, "Error: Failed to read new page\n");
            return -1;
        }
        
        // æ›´æ–°é¡µé¢é“¾è¡¨
        if (meta->last_page != INVALID_PAGE_ID) {
            Page last_page;
            if (read_page(path, meta->last_page, &last_page) == 0) {
                last_page.header.next_page = new_page_id;
                current_page.header.prev_page = meta->last_page;
                write_page(path, &last_page);
            }
        } else {
            // è¿™æ˜¯è¡¨çš„ç¬¬ä¸€ä¸ªé¡µé¢
            meta->first_page = new_page_id;
        }
        meta->last_page = new_page_id;
        
        // æ›´æ–°ç›®å½•
        update_table_meta(&db->catalog, meta);
        
        // æ·»åŠ å…ƒç»„åˆ°æ–°é¡µé¢
        if (add_tuple_to_page(&current_page, tuple) >= 0) {
            if (write_page(path, &current_page) != 0) {
                fprintf(stderr, "Error: Failed to write new page\n");
                return -1;
            }
            inserted = 1;
        }
    }
    
    if (!inserted) {
        fprintf(stderr, "Error: Failed to insert tuple\n");
        return -1;
    }
    
    return 0; // æˆåŠŸæ’å…¥
}
// minidb.c
Tuple** db_query(MiniDB *db, const char *table_name, int *result_count) {
    *result_count = 0;
    Tuple** results = NULL;
    
    if (db->current_xid == INVALID_XID) {
        fprintf(stderr, "Error: No active transaction\n");
        return NULL;
    }
    
    TableMeta *meta = find_table(&db->catalog, table_name);
    if (!meta) {
        fprintf(stderr, "Error: Table '%s' not found\n", table_name);
        return NULL;
    }
    
    // æ„é€ è¡¨æ•°æ®æ–‡ä»¶è·¯å¾„
    char path[256];
    snprintf(path, sizeof(path), "%s/%s", db->data_dir, meta->filename);
    

    
    // ä¸´æ—¶ç»“æœé›†æ•°ç»„
    Tuple** temp_results = malloc(MAX_RESULTS * sizeof(Tuple*));
    if (!temp_results) {
        fprintf(stderr, "Error: Memory allocation failed\n");
        return NULL;
    }
    
    // éå†æ‰€æœ‰é¡µé¢
    PageID current_page_id = meta->first_page;
    Page current_page;
    
    while (current_page_id != INVALID_PAGE_ID && *result_count < MAX_RESULTS) {
        if (read_page(path, current_page_id, &current_page) != 0) {
            fprintf(stderr, "Error reading page %u\n", current_page_id);
            break;
        }
        
        // éå†é¡µé¢ä¸­çš„å…ƒç»„
        for (int i = 0; i < current_page.header.tuple_count; i++) {
            if (*result_count >= MAX_RESULTS) break;
            
            // ç›´æ¥è®¿é—®å…ƒç»„æˆå‘˜
            Tuple *tuple = &current_page.tuples[i];
            
            // è®¿é—® deleted æˆå‘˜
            if (tuple->deleted) continue;
            
            // è®¿é—® xmin å’Œ xmax æˆå‘˜
            if (txmgr_is_visible(&db->tx_mgr, db->current_xid, tuple->xmin, tuple->xmax)) {
                // å¤åˆ¶å…ƒç»„ï¼ˆæ·±åº¦å¤åˆ¶ï¼‰
                Tuple* result_tuple = copy_tuple(tuple);
                if (result_tuple) {
                    temp_results[*result_count] = result_tuple;
                    (*result_count)++;
                }
            }
        }
        
        // ç§»åŠ¨åˆ°ä¸‹ä¸€é¡µ
        current_page_id = current_page.header.next_page;
    }
    
    // åˆ›å»ºæœ€ç»ˆç»“æœé›†
    if (*result_count > 0) {
        results = malloc(*result_count * sizeof(Tuple*));
        if (results) {
            memcpy(results, temp_results, *result_count * sizeof(Tuple*));
        }
    }
    
    free(temp_results);
    return results;
}


// æ·±åº¦å¤åˆ¶å…ƒç»„
Tuple* copy_tuple(const Tuple* src) {
    if (!src) return NULL;
    
    Tuple* dest = malloc(sizeof(Tuple));
    if (!dest) return NULL;
    
    // å¤åˆ¶åŸºæœ¬å­—æ®µ
    dest->oid = src->oid;
    dest->xmin = src->xmin;
    dest->xmax = src->xmax;
    dest->deleted = src->deleted;
    dest->col_count = src->col_count;
    
    // åˆ†é…åˆ—æ•°ç»„
    dest->columns = malloc(dest->col_count * sizeof(Column));
    if (!dest->columns) {
        free(dest);
        return NULL;
    }
    
    // å¤åˆ¶æ¯åˆ—æ•°æ®
    for (int i = 0; i < dest->col_count; i++) {
        dest->columns[i].type = src->columns[i].type;
        
        switch (src->columns[i].type) {
            case TEXT_TYPE:
                // å­—ç¬¦ä¸²éœ€è¦æ·±åº¦å¤åˆ¶
                dest->columns[i].value.str_val = strdup(src->columns[i].value.str_val);
                if (!dest->columns[i].value.str_val) {
                    // æ¸…ç†å·²åˆ†é…çš„å†…å­˜
                    for (int j = 0; j < i; j++) {
                        if (dest->columns[j].type == TEXT_TYPE) {
                            free(dest->columns[j].value.str_val);
                        }
                    }
                    free(dest->columns);
                    free(dest);
                    return NULL;
                }
                break;
            default:
                // å…¶ä»–ç±»å‹ç›´æ¥å¤åˆ¶å€¼
                dest->columns[i].value = src->columns[i].value;
        }
    }
    
    return dest;
}
// é‡Šæ”¾æŸ¥è¯¢ç»“æœ
void free_query_results(Tuple** results, int count) {
    if (!results) return;
    
    for (int i = 0; i < count; i++) {
        if (results[i]) {
            free_tuple(results[i]);
        }
    }
    free(results);
}
// åˆ›å»ºæ£€æŸ¥ç‚¹
void db_create_checkpoint(MiniDB *db) {
    wal_log_checkpoint();
}

// æ‰“å°æ•°æ®åº“çŠ¶æ€
void print_db_status(const MiniDB *db) {
    printf("\n===== Database Status =====\n");
    printf("Data Directory: %s\n", db->data_dir);
    printf("Current Transaction ID: %u\n", db->current_xid);
    
    // æ‰“å°ç³»ç»Ÿç›®å½•çŠ¶æ€
    printf("\nSystem Catalog:\n");
    printf("  Tables: %d\n", db->catalog.table_count);
    for (int i = 0; i < db->catalog.table_count; i++) {
        const TableMeta *meta = &db->catalog.tables[i];
        printf("  - %s (OID: %u, File: %s)\n", 
               meta->name, meta->oid, meta->filename);
        printf("    Columns: %d\n", meta->col_count);
        for (int j = 0; j < meta->col_count; j++) {
            printf("      %s: %s\n", 
                   meta->cols[j].name,
                   meta->cols[j].type == INT4_TYPE ? "INT" : "TEXT");
        }
    }
    
    // æ‰“å°äº‹åŠ¡ç®¡ç†å™¨çŠ¶æ€
    txmgr_print_status(&db->tx_mgr);
}




// åˆå§‹åŒ–ç³»ç»Ÿç›®å½•
void init_system_catalog(SystemCatalog *catalog) {
    catalog->table_count = 0;
    catalog->next_oid = 1000;
}

// åˆ›å»ºæ–°è¡¨
int create_table(SystemCatalog *catalog, const char *table_name, ColumnDef *columns, uint8_t col_count) {
    if (catalog->table_count >= MAX_TABLES) {
        return -1;
    }
    
    TableMeta *meta = &catalog->tables[catalog->table_count];
    meta->oid = catalog->next_oid++;
    strncpy(meta->name, table_name, MAX_NAME_LEN);
    snprintf(meta->filename, MAX_NAME_LEN, "%u.dat", meta->oid);
    meta->col_count = col_count;
    
    for (int i = 0; i < col_count; i++) {
        meta->cols[i] = columns[i];
    }
    
    catalog->table_count++;
    return meta->oid;
}

// æŒ‰åç§°æŸ¥æ‰¾è¡¨
TableMeta *find_table(SystemCatalog *catalog, const char *table_name) {
    for (int i = 0; i < catalog->table_count; i++) {
        if (strcmp(catalog->tables[i].name, table_name) == 0) {
            return &catalog->tables[i];
        }
    }
    return NULL;
}


/**
 * æŸ¥è¯¢è¡¨ä¸­çš„æ‰€æœ‰å…ƒç»„
 * 
 * @param db æ•°æ®åº“å®ä¾‹
 * @param table_name è¡¨å
 * @param result_count è¿”å›ç»“æœæ•°é‡
 * @return å…ƒç»„æŒ‡é’ˆæ•°ç»„ï¼Œéœ€è¦è°ƒç”¨è€…é‡Šæ”¾
 */
Tuple** nocache_db_query(MiniDB *db, const char *table_name, int *result_count,Session session) {
    if (!db || !table_name || !result_count) {
        return NULL;
    }
    
    *result_count = 0;
    
    // æŸ¥æ‰¾è¡¨å…ƒæ•°æ®
  int idx= find_table(&db->catalog, table_name);
    TableMeta *meta =&(db->catalog.tables[idx]);
    if (!meta) {
        fprintf(stderr, "Table '%s' not found\n", table_name);
        return NULL;
    }
    fprintf(stderr, "for Table '%s',file  found:%s\n", table_name,meta->filename);
    
    // æ‰“å¼€è¡¨æ–‡ä»¶
    char fullpath[256];  // æˆ–è€…åŠ¨æ€åˆ†é…æ›´å®‰å…¨
snprintf(fullpath, sizeof(fullpath), "%s/%s", db->data_dir, meta->filename);
    FILE *table_file = fopen(fullpath, "r+b");
    if (!table_file) {
        perror("Failed to open table file");
        return NULL;
    }
    
    // åˆ†é…ç»“æœæ•°ç»„
    Tuple** results = malloc(MAX_RESULTS * sizeof(Tuple*));
    if (!results) {
        fclose(table_file);
        return NULL;
    }
    
    // è¯»å–é¡µé¢
    Page page;
    int page_count = 0;
    int total_tuples = 0;
    
    while (fread(&page, sizeof(Page), 1, table_file) == 1) {
        page_count++;
        
        // éªŒè¯é¡µé¢
        if (page.header.page_id == INVALID_PAGE_ID) {
            continue;
        }
        
        // è·å–æ§½ä½æ•°ç»„
        Slot* slots = page.slots;//(Slot*)page.data;
        printf("DEBUG: page.header.slot_count%d\n",page.header.slot_count);

        // éå†æ‰€æœ‰æ§½ä½
        for (int i = 0; i < page.header.slot_count; i++) {
            Tuple* t = page_get_tuple(&page, i, meta);
            if (!t) continue;
            //printf("DEBUG: slot %d â†’ oid=%u, xmin=%u, xmax=%u, deleted=%d\n",i, t->oid, t->xmin, t->xmax, t->deleted);

            // === ğŸ” MVCC å¯è§æ€§åˆ¤æ–­æ ¸å¿ƒé€»è¾‘ ===
            bool visible = true;
            uint32_t xid = session.current_xid;

            // åªå¯¹æœªè¢«åˆ é™¤çš„ã€å¯¹å½“å‰äº‹åŠ¡å¯è§çš„å…ƒç»„ç”Ÿæ•ˆ
            if ((t->deleted == false) &&
                (t->xmin <= xid) &&
                (t->xmax == 0 || t->xmax > xid)) {
                visible = true;
            }

            if (visible) {
                if (total_tuples < MAX_RESULTS) {
                    results[total_tuples++] = t;
                    //printf("DEBUG: tuple xmin= %d\n",t->xmin);

                } else {
                    printf("DEBUG: before free t\n");
                    free_tuple(t);
                }
            } else {
                printf("DEBUG: before free t else\n");
                free_tuple(t);
            }
        
        }
    }
    
    fclose(table_file);
    
    // å¤„ç†ç»“æœ
    if (total_tuples == 0) {
        free(results);
        results = NULL;
    } else {
        // è°ƒæ•´ç»“æœæ•°ç»„å¤§å°
         printf("DEBUG:total_tuples=%d\n",total_tuples);

        Tuple** tmp = realloc(results, total_tuples * sizeof(Tuple*));
        //printf("DEBUG:tmp=%s\n",tmp);
        if (tmp) {
            results = tmp;
        }
    }
    
    *result_count = total_tuples;

   // save_table_meta_to_file(meta, db->data_dir);
    return results;
}